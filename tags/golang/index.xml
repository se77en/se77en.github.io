<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 罄竹难书</title>
    <link>https://se77en.cc/tags/golang/index.xml</link>
    <description>Recent content in Golang on 罄竹难书</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://se77en.cc/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>使用 buffered channel 实现线程安全的 pool</title>
      <link>https://se77en.cc/2014/%E4%BD%BF%E7%94%A8-buffered-channel-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-pool/</link>
      <pubDate>Mon, 14 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/%E4%BD%BF%E7%94%A8-buffered-channel-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-pool/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;我们已经知道 Go 语言提供了 sync.Pool，但是做的不怎么好，所以有必要自己来实现一个 pool。&lt;/del&gt;
&lt;/p&gt;

&lt;h2 id=&#34;给我看代码&#34;&gt;给我看代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;type Pool struct {
  pool chan *Client
}

// 创建一个新的 pool
func NewPool(max int) *Pool {
  return &amp;amp;Pool{
    pool: make(chan *Client, max),
  }
}

// 从 pool 里借一个 Client
func (p *Pool) Borrow() *Client {
  var cl *Client
  select {
  case cl = &amp;lt;-p.pool:
  default:
    cl = newClient()
  }
  return cl
}

// 还回去
func (p *Pool) Return(cl *Client) {
  select {
  case p.pool &amp;lt;- cl:
  default:
    // let it go, let it go...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;现在&lt;strong&gt;&lt;em&gt;不要&lt;/em&gt;&lt;/strong&gt;使用 &lt;code&gt;sync.Pool&lt;/code&gt;&lt;/del&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 Array，Slice，Map 和 Set</title>
      <link>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-arrayslicemap-%E5%92%8C-set/</link>
      <pubDate>Mon, 30 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-arrayslicemap-%E5%92%8C-set/</guid>
      <description>&lt;h2 id=&#34;array-数组&#34;&gt;Array(数组)&lt;/h2&gt;

&lt;h3 id=&#34;内部机制&#34;&gt;内部机制&lt;/h3&gt;

&lt;p&gt;在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。&lt;/p&gt;

&lt;p&gt;数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。
&lt;/p&gt;

&lt;h3 id=&#34;数组声明和初始化&#34;&gt;数组声明和初始化&lt;/h3&gt;

&lt;p&gt;通过指定数据类型和元素个数(数组长度)来声明数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明一个长度为5的整数数组
var array [5]int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。&lt;/p&gt;

&lt;p&gt;Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。&lt;/p&gt;

&lt;p&gt;一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明一个长度为5的整数数组
// 初始化每个元素
array := [5]int{7, 77, 777, 7777, 77777}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你把长度写成 &lt;code&gt;...&lt;/code&gt;，Go 编译器将会根据你的元素来推导出长度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通过初始化值的个数来推导出数组容量
array := [...]int{7, 77, 777, 7777, 77777}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明一个长度为5的整数数组
// 为索引为1和2的位置指定元素初始化
// 剩余元素为0值
array := [5]int{1: 77, 2: 777}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用数组&#34;&gt;使用数组&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;[]&lt;/code&gt; 操作符来访问数组元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;array := [5]int{7, 77, 777, 7777, 77777}
// 改变索引为2的元素的值
array[2] = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以定义一个指针数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;array := [5]*int{0: new(int), 1: new(int)}

// 为索引为0和1的元素赋值
*array[0] = 7
*array[1] = 77
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array1 [5]string
array2 := [5]string{&amp;quot;Red&amp;quot;, &amp;quot;Blue&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Pink&amp;quot;}
array1 = array2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array1 [4]string
array2 := [5]string{&amp;quot;Red&amp;quot;, &amp;quot;Blue&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Pink&amp;quot;}
array1 = array2

// 编译器会报错
Compiler Error:
cannot use array2 (type [5]string) as type [4]string in assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array1 [3]*string
array2 := [3]*string{new(string), new(string), new(string)}
*array2[0] = &amp;quot;Red&amp;quot;
*array2[1] = &amp;quot;Blue&amp;quot;
*array2[2] = &amp;quot;Green&amp;quot;

array1 = array2
// 赋值完成后，两组指针数组指向同一字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;多维数组&#34;&gt;多维数组&lt;/h3&gt;

&lt;p&gt;数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明一个二维数组
var array [4][2]int

// 使用数组字面值声明并初始化
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

// 指定外部数组索引位置初始化
array := [4][2]int{1: {20, 21}, 3: {40, 41}}

// 同时指定内外部数组索引位置初始化
array := [4][2]int{1: {0: 20}, 3: {1: 41}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样通过 &lt;code&gt;[]&lt;/code&gt; 操作符来访问数组元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array [2][2]int

array[0][0] = 0
array[0][1] = 1
array[1][0] = 2
array[1][1] = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也同样的相同类型的多维数组可以相互赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array1 = [2][2]int
var array2 = [2][2]int

array[0][0] = 0
array[0][1] = 1
array[1][0] = 2
array[1][1] = 3

array1 = array2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为数组是值，我们可以拷贝单独的维：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array3 [2]int = array1[1]
var value int = array1[1][0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在函数中传递数组&#34;&gt;在函数中传递数组&lt;/h3&gt;

&lt;p&gt;在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。&lt;/p&gt;

&lt;p&gt;举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array [1e6]int
foo(array)
func foo(array [1e6]int) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一次 &lt;code&gt;foo&lt;/code&gt; 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。&lt;/p&gt;

&lt;p&gt;Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array [1e6]int
foo(&amp;amp;array)
func foo(array *[1e6]int){
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 &lt;code&gt;slice&lt;/code&gt;(切片)可以帮我们处理好这些问题，来一起看看。&lt;/p&gt;

&lt;h2 id=&#34;slice-切片&#34;&gt;Slice(切片)&lt;/h2&gt;

&lt;h3 id=&#34;内部机制和基础&#34;&gt;内部机制和基础&lt;/h3&gt;

&lt;p&gt;slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 &lt;code&gt;append&lt;/code&gt; 方法。我们也可以通过 &lt;strong&gt;&lt;em&gt;relice&lt;/em&gt;&lt;/strong&gt; 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。&lt;/p&gt;

&lt;p&gt;slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;指向底层数组的指针&lt;/li&gt;
&lt;li&gt;slice 中元素的长度&lt;/li&gt;
&lt;li&gt;slice 的容量(可供增长的最大值)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;创建和初始化&#34;&gt;创建和初始化&lt;/h3&gt;

&lt;p&gt;Go 中创建 slice 有很多种方法，我们一个一个来看。&lt;/p&gt;

&lt;p&gt;第一个方法是使用内建的函数 &lt;code&gt;make&lt;/code&gt;。当我们使用 &lt;code&gt;make&lt;/code&gt; 创建时，一个选项是可以指定 slice 的长度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := make([]string, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := make([]int, 3, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。&lt;/p&gt;

&lt;p&gt;不允许创建长度大于容量的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := make([]int, 5, 3)

Compiler Error:
len larger than cap in make([]int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 &lt;code&gt;[]&lt;/code&gt;里的值。初始的长度和容量依赖于元素的个数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建一个字符串 slice
// 长度和容量都是 5
slice := []string{&amp;quot;Red&amp;quot;, &amp;quot;Blue&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Pink&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建一个字符串 slice
// 初始化一个有100个元素的空的字符串 slice
slice := []string{99: &amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nil-和-empty-slice&#34;&gt;nil 和 empty slice&lt;/h3&gt;

&lt;p&gt;有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var slice []int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。&lt;/p&gt;

&lt;p&gt;创建 empty slice 的方法就是声明并初始化一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 使用 make 创建
silce := make([]int, 0)

// 使用 slice 字面值创建
slice := []int{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。&lt;/p&gt;

&lt;p&gt;不管我们用 nil slice 还是 empty slice，内建函数 &lt;code&gt;append&lt;/code&gt;，&lt;code&gt;len&lt;/code&gt;和&lt;code&gt;cap&lt;/code&gt;的工作方式完全相同。&lt;/p&gt;

&lt;h3 id=&#34;使用-slice&#34;&gt;使用 slice&lt;/h3&gt;

&lt;p&gt;为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 &lt;code&gt;[]&lt;/code&gt; 操作符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30, 40, 50}
slice[1] = 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 长度为5，容量为5
slice := []int{10, 20, 30, 40, 50}

// 长度为2，容量为4
newSlice := slice[1:3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。&lt;/p&gt;

&lt;p&gt;计算任意 new slice 的长度和容量可以使用下面的公式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对于 slice[i:j] 和底层容量为 k 的数组
长度：j - i
容量：k - i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
newSlice[1] = 35
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。&lt;/p&gt;

&lt;p&gt;一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
newSlice[3] = 45

Runtime Exception:
panic: runtime error: index out of range

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容量可以被合并到长度里，通过内建的 &lt;code&gt;append&lt;/code&gt; 函数。&lt;/p&gt;

&lt;h3 id=&#34;slice-增长&#34;&gt;slice 增长&lt;/h3&gt;

&lt;p&gt;slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 &lt;code&gt;append&lt;/code&gt; 方法，然后 Go 会为我们做好一切。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;append&lt;/code&gt; 方法时我们需要一个源 slice 和需要附加到它里面的值。当 &lt;code&gt;append&lt;/code&gt; 方法返回时，它返回一个新的 slice，&lt;code&gt;append&lt;/code&gt; 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建一个长度和容量都为5的 slice
slice := []int{10, 20, 30, 40, 50}

// 创建一个新的 slice
newSlice := slice[1:3]

// 为新的 slice append 一个值
newSlice = append(newSlice, 60)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 newSlice 有可用的容量，所以在 &lt;code&gt;append&lt;/code&gt; 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。&lt;/p&gt;

&lt;p&gt;如果没有足够可用的容量，&lt;code&gt;append&lt;/code&gt; 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建长度和容量都为4的 slice
slice := []int{10, 20, 30, 40}

// 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组
newSlice := append(slice, 50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。&lt;/p&gt;

&lt;h3 id=&#34;slice-的第三个索引参数&#34;&gt;slice 的第三个索引参数&lt;/h3&gt;

&lt;p&gt;slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 &lt;code&gt;append&lt;/code&gt; 操作，举个栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source := []string{&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;plum&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;grape&amp;quot;}

// 接着我们在源 slice 之上创建一个新的 slice
slice := source[2:3:4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对于 slice[i:j:k]  或者 [2:3:4]

长度： j - i       或者   3 - 2
容量： k - i       或者   4 - 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们试图设置比可用容量更大的容量，会得到一个运行时错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := source[2:3:6]


Runtime Error:
panic: runtime error: slice bounds out of range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source := []string{&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;plum&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;grape&amp;quot;}

// 接着我们在源 slice 之上创建一个新的 slice
// 并且设置长度和容量相同
slice := source[2:3:3]

// 添加一个新元素
slice = append(slice, &amp;quot;kiwi&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。&lt;/p&gt;

&lt;p&gt;内建函数 &lt;code&gt;append&lt;/code&gt; 是一个变参函数，意思就是你可以一次添加多个元素，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s1 := []int{1, 2}
s2 := []int{3, 4}

fmt.Printf(&amp;quot;%v\n&amp;quot;, append(s1, s2...))

Output:
[1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;迭代-slice&#34;&gt;迭代 slice&lt;/h3&gt;

&lt;p&gt;slice 也是一种集合，所以可以被迭代，用 &lt;code&gt;for&lt;/code&gt; 配合 &lt;code&gt;range&lt;/code&gt; 来迭代：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30, 40, 50}

for index, value := range slice {
  fmt.Printf(&amp;quot;Index: %d  Value: %d\n&amp;quot;, index, value)
}

Output:
Index: 0  Value: 10
Index: 1  Value: 20
Index: 2  Value: 30
Index: 3  Value: 40
Index: 4  Value: 50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当迭代时 &lt;code&gt;range&lt;/code&gt; 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30 ,40}

for index, value := range slice {
  fmt.Printf(&amp;quot;Value: %d  Value-Addr: %X  ElemAddr: %X\n&amp;quot;, value, &amp;amp;value, &amp;amp;slice[index])
}

Output:
Value: 10  Value-Addr: 10500168  ElemAddr: 1052E100
Value: 20  Value-Addr: 10500168  ElemAddr: 1052E104
Value: 30  Value-Addr: 10500168  ElemAddr: 1052E108
Value: 40  Value-Addr: 10500168  ElemAddr: 1052E10C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;amp;slice[index]。&lt;/p&gt;

&lt;p&gt;如果不需要索引值，可以使用 &lt;code&gt;_&lt;/code&gt; 操作符来忽略它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30, 40}

for _, value := range slice {
  fmt.Printf(&amp;quot;Value: %d\n&amp;quot;, value)
}


Output:
Value: 10
Value: 20
Value: 30
Value: 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;range&lt;/code&gt; 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 &lt;code&gt;for&lt;/code&gt; 循环：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := []int{10, 20, 30, 40}

for index := 2; index &amp;amp;lt; len(slice); index++ {
  fmt.Printf(&amp;quot;Index: %d  Value: %d\n&amp;quot;, index, slice[index])
}


Output:
Index: 2  Value: 30
Index: 3  Value: 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同数组一样，另外两个内建函数 &lt;code&gt;len&lt;/code&gt; 和 &lt;code&gt;cap&lt;/code&gt; 分别返回 slice 的长度和容量。&lt;/p&gt;

&lt;h3 id=&#34;多维-slice&#34;&gt;多维 slice&lt;/h3&gt;

&lt;p&gt;也是同数组一样，slice 可以组合为多维的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := [][]int{{10}, {20, 30}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是使用 &lt;code&gt;append&lt;/code&gt; 方法时的行为，比如我们现在对 slice[0] 增加一个元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := [][]int{{10}, {20, 30}}
slice[0] = append(slice[0], 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。&lt;/p&gt;

&lt;h3 id=&#34;在函数间传递-slice&#34;&gt;在函数间传递 slice&lt;/h3&gt;

&lt;p&gt;在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice := make([]int, 1e6)

slice = foo(slice)

func foo(slice []int) []int {
    ...
    return slice
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 64 位的机器上，slice 需要 24 字节的内存，其中指针部分需要 8 字节，长度和容量也分别需要 8 字节。&lt;/p&gt;

&lt;h2 id=&#34;map&#34;&gt;Map&lt;/h2&gt;

&lt;h3 id=&#34;内部机制-1&#34;&gt;内部机制&lt;/h3&gt;

&lt;p&gt;map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。&lt;/p&gt;

&lt;p&gt;map 是一种集合，所以我们可以像迭代数组和 slice 那样迭代它。不过，map 是无序的，我们无法决定它的返回顺序，这是因为 map 是使用 hash 表来实现的。&lt;/p&gt;

&lt;p&gt;map 的 hash 表包含了一个桶集合(collection of buckets)。当我们存储，移除或者查找键值对(key/value pair)时，都会从选择一个桶开始。在映射(map)操作过程中，我们会把指定的键值(key)传递给 hash 函数(又称散列函数)。hash 函数的作用是生成索引，索引均匀的分布在所有可用的桶上。hash 表算法详见：&lt;a href=&#34;http://blog.csdn.net/v_JULY_v/article/details/6256463&#34;&gt;July的博客&amp;ndash;从头到尾彻底解析 hash 表算法&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;创建和初始化-1&#34;&gt;创建和初始化&lt;/h3&gt;

&lt;p&gt;Go 语言中有多种方法创建和初始化 map。我们可以使用内建函数 &lt;code&gt;make&lt;/code&gt; 也可以使用 map 字面值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通过 make 来创建
dict := make(map[string]int)

// 通过字面值创建
dict := map[string]string{&amp;quot;Red&amp;quot;: &amp;quot;#da1337&amp;quot;, &amp;quot;Orange&amp;quot;: &amp;quot;#e95a22&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用字面值是创建 map 惯用的方法(&lt;a href=&#34;http://peter.bourgon.org/go-in-production/#formatting-and-style&#34;&gt;为什么不使用make&lt;/a&gt;)。初始化 map 的长度依赖于键值对的数量。&lt;/p&gt;

&lt;p&gt;map 的键可以是任意内建类型或者是 struct 类型，map 的值可以是使用 &lt;code&gt;==&lt;/code&gt;操作符的表达式。slice，function 和 包含 slice 的 struct 类型不可以作为 map 的键，否则会编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dict := map[[]string]int{}

Compiler Exception:
invalid map key type []string
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-map&#34;&gt;使用 map&lt;/h3&gt;

&lt;p&gt;给 map 赋值就是指定合法类型的键，然后把值赋给键：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;colors := map[string]string{}
colors[&amp;quot;Red&amp;quot;] = &amp;quot;#da1337&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对，否则会报运行时错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var colors map[string]string
colors[&amp;quot;Red&amp;quot;] = &amp;quot;#da1337&amp;quot;

Runtime Error:
panic: runtime error: assignment to entry in nil map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试 map 的键是否存在是 map 操作的重要部分，因为它可以让我们判断是否可以执行一个操作，或者是往 map 里缓存一个值。它也可以被用来比较两个 map 的键值对是否匹配或者缺失。&lt;/p&gt;

&lt;p&gt;从 map 里检索一个值有两种选择，我们可以同时检索值并且判断键是否存在：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value, exists := colors[&amp;quot;Blue&amp;quot;]
if exists {
  fmt.Println(value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种选择是只返回值，然后判断是否是零值来确定键是否存在。但是只有你确定零值是非法值的时候这招才管用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;value := colors[&amp;quot;Blue&amp;quot;]
if value != &amp;quot;&amp;quot; {
  fmt.Println(value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当索引一个 map 取值时它总是会返回一个值，即使键不存在。上面的例子就返回了对应类型的零值。&lt;/p&gt;

&lt;p&gt;迭代一个 map 和迭代数组和 slice 是一样的，使用 &lt;code&gt;range&lt;/code&gt; 关键字，不过在迭代 map 时我们不使用 index/value 而使用 key/value 结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;colors := map[string]string{
    &amp;quot;AliceBlue&amp;quot;:   &amp;quot;#f0f8ff&amp;quot;,
    &amp;quot;Coral&amp;quot;:       &amp;quot;#ff7F50&amp;quot;,
    &amp;quot;DarkGray&amp;quot;:    &amp;quot;#a9a9a9&amp;quot;,
    &amp;quot;ForestGreen&amp;quot;: &amp;quot;#228b22&amp;quot;,
}

for key, value := range colors {
  fmt.Printf(&amp;quot;Key: %s  Value: %s\n&amp;quot;, key, value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想要从 map 中移除一个键值对，使用内建函数 &lt;code&gt;delete&lt;/code&gt;(要是也能返回移除是否成功就好了，哎。。。)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delete(colors, &amp;quot;Coral&amp;quot;)

for key, value := range colors {
  fmt.Println(&amp;quot;Key: %s  Value: %s\n&amp;quot;, key, value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在函数间传递-map&#34;&gt;在函数间传递 map&lt;/h3&gt;

&lt;p&gt;在函数间传递 map 不是传递 map 的拷贝。所以如果我们在函数中改变了 map，那么所有引用 map 的地方都会改变：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  colors := map[string]string{
     &amp;quot;AliceBlue&amp;quot;:   &amp;quot;#f0f8ff&amp;quot;,
     &amp;quot;Coral&amp;quot;:       &amp;quot;#ff7F50&amp;quot;,
     &amp;quot;DarkGray&amp;quot;:    &amp;quot;#a9a9a9&amp;quot;,
     &amp;quot;ForestGreen&amp;quot;: &amp;quot;#228b22&amp;quot;,
  }

  for key, value := range colors {
      fmt.Printf(&amp;quot;Key: %s  Value: %s\n&amp;quot;, key, value)
  }

  removeColor(colors, &amp;quot;Coral&amp;quot;)

  for key, value := range colors {
      fmt.Printf(&amp;quot;Key: %s  Value: %s\n&amp;quot;, key, value)
  }
}

func removeColor(colors map[string]string, key string) {
    delete(colors, key)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行会得到以下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Key: AliceBlue Value: #F0F8FF
Key: Coral Value: #FF7F50
Key: DarkGray Value: #A9A9A9
Key: ForestGreen Value: #228B22
    
Key: AliceBlue Value: #F0F8FF
Key: DarkGray Value: #A9A9A9
Key: ForestGreen Value: #228B22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出来传递 map 也是十分廉价的，类似 slice。&lt;/p&gt;

&lt;h2 id=&#34;set&#34;&gt;Set&lt;/h2&gt;

&lt;p&gt;Go 语言本身是不提供 set 的，但是我们可以自己实现它，下面就来试试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import(
  &amp;quot;fmt&amp;quot;
  &amp;quot;sync&amp;quot;
)

type Set struct {
  m map[int]bool
  sync.RWMutex
}

func New() *Set {
  return &amp;amp;Set{
    m: map[int]bool{},
  }
}

func (s *Set) Add(item int) {
  s.Lock()
  defer s.Unlock()
  s.m[item] = true
}

func (s *Set) Remove(item int) {
  s.Lock()
  s.Unlock()
  delete(s.m, item)
}

func (s *Set) Has(item int) bool {
  s.RLock()
  defer s.RUnlock()
  _, ok := s.m[item]
  return ok
}

func (s *Set) Len() int {
  return len(s.List())
}

func (s *Set) Clear() {
  s.Lock
  defer s.Unlock()
  s.m = map[int]bool{}
}

func (s *Set) IsEmpty() bool {
  if s.Len() == 0 {
    return true
  }
  return false
}

func (s *Set) List() []int {
  s.RLock()
  defer s.RUnlock()
  list := []int{}
  for item := range s.m {
    list = append(list, item)
  }
  return list
}

func main() {
  // 初始化
  s := New()
  
  s.Add(1)
  s.Add(1)
  s.Add(2)

  s.Clear()
  if s.IsEmpty() {
    fmt.Println(&amp;quot;0 item&amp;quot;)
  }
  
  s.Add(1)
  s.Add(2)
  s.Add(3)
  
  if s.Has(2) {
    fmt.Println(&amp;quot;2 does exist&amp;quot;)
  }
  
  s.Remove(2)
  s.Remove(3)
  fmt.Println(&amp;quot;list of all items&amp;quot;, S.List())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意我们只是使用了 int 作为键，你可以自己实现用 interface{} 作为键，做成更通用的 Set，另外，这个实现是线程安全的。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数组是 slice 和 map 的底层结构。&lt;/li&gt;
&lt;li&gt;slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。&lt;/li&gt;
&lt;li&gt;内建函数 &lt;code&gt;make&lt;/code&gt; 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。&lt;/li&gt;
&lt;li&gt;slice 有容量的约束，不过可以通过内建函数 &lt;code&gt;append&lt;/code&gt; 来增加元素。&lt;/li&gt;
&lt;li&gt;map 没有容量一说，所以也没有任何增长限制。&lt;/li&gt;
&lt;li&gt;内建函数 &lt;code&gt;len&lt;/code&gt; 可以用来获得 slice 和 map 的长度。&lt;/li&gt;
&lt;li&gt;内建函数 &lt;code&gt;cap&lt;/code&gt; 只能作用在 slice 上。&lt;/li&gt;
&lt;li&gt;可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。&lt;/li&gt;
&lt;li&gt;在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的方法，接口和嵌入类型</title>
      <link>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 05 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在 Go 语言中，如果一个结构体和一个嵌入字段同时实现了相同的接口会发生什么呢？我们猜一下，可能有两个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译器会因为我们同时有两个接口实现而报错吗？&lt;/li&gt;
&lt;li&gt;如果编译器接受这样的定义，那么当接口调用时编译器要怎么确定该使用哪个实现？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在写了一些测试代码并认真深入的读了一下标准之后，我发现了一些有意思的东西，而且觉得很有必要分享出来，那么让我们先从 Go 语言中的方法开始说起。
&lt;/p&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;Go 语言中同时有函数和方法。一个方法就是一个包含了&lt;a href=&#34;http://golang.org/ref/spec#Method_declarations&#34;&gt;接受者&lt;/a&gt;的函数，接受者可以是&lt;a href=&#34;http://golang.org/ref/spec#Types&#34;&gt;命名类型&lt;/a&gt;或者&lt;a href=&#34;http://golang.org/ref/spec#Struct_types&#34;&gt;结构体&lt;/a&gt;类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。&lt;/p&gt;

&lt;p&gt;下面定义一个结构体类型和该类型的一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
  Name  string
  Email string
}

func (u User) Notify() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们定义了一个叫做 &lt;code&gt;User&lt;/code&gt; 的结构体类型，然后定义了一个该类型的方法叫做 &lt;code&gt;Notify&lt;/code&gt;，该方法的接受者是一个 &lt;code&gt;User&lt;/code&gt; 类型的值。要调用 &lt;code&gt;Notify&lt;/code&gt; 方法我们需要一个 &lt;code&gt;User&lt;/code&gt; 类型的值或者指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// User 类型的值可以调用接受者是值的方法
damon := User{&amp;quot;AriesDevil&amp;quot;, &amp;quot;ariesdevil@xxoo.com&amp;quot;}
damon.Notify()

// User 类型的指针同样可以调用接受者是值的方法
alimon := &amp;amp;User{&amp;quot;A-limon&amp;quot;, &amp;quot;alimon@ooxx.com&amp;quot;}
alimon.Notify()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中当我们使用指针时，Go &lt;a href=&#34;http://golang.org/ref/spec#Calls&#34;&gt;调整&lt;/a&gt;和解引用指针使得调用可以被执行。&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作，参见：&lt;a href=&#34;http://play.golang.org/p/DBhWU0p1Pv&#34;&gt;http://play.golang.org/p/DBhWU0p1Pv&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;我们可以修改 &lt;code&gt;Notify&lt;/code&gt; 方法，让它的接受者使用指针类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (u *User) Notify() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来一次之前的调用(&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作，参见：&lt;a href=&#34;http://play.golang.org/p/SYBb4xPfPh&#34;&gt;http://play.golang.org/p/SYBb4xPfPh&lt;/a&gt;)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// User 类型的值可以调用接受者是指针的方法
damon := User{&amp;quot;AriesDevil&amp;quot;, &amp;quot;ariesdevil@xxoo.com&amp;quot;}
damon.Notify()

// User 类型的指针同样可以调用接受者是指针的方法
alimon := &amp;amp;User{&amp;quot;A-limon&amp;quot;, &amp;quot;alimon@ooxx.com&amp;quot;}
alimon.Notify()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不清楚到底什么时候该使用值，什么时候该使用指针作为接受者，你可以去看一下&lt;a href=&#34;http://se77en.cc/2014/05/04/choose-whether-to-use-a-value-or-pointer-receiver-on-methods/&#34;&gt;这篇介绍&lt;/a&gt;。这篇文章同时还包含了社区约定的接受者该如何命名。&lt;/p&gt;

&lt;h2 id=&#34;接口&#34;&gt;接口&lt;/h2&gt;

&lt;p&gt;Go 语言中的&lt;a href=&#34;http://golang.org/doc/effective_go.html#interfaces&#34;&gt;接口&lt;/a&gt;很特别，而且提供了难以置信的一系列灵活性和抽象性。它们指定一个特定类型的值和指针表现为特定的方式。从语言角度看，接口是一种类型，它指定一个&lt;a href=&#34;http://golang.org/ref/spec#Method_sets&#34;&gt;方法集&lt;/a&gt;，所有方法为&lt;a href=&#34;http://golang.org/ref/spec#Interface_types&#34;&gt;接口类型&lt;/a&gt;就被认为是该接口。&lt;/p&gt;

&lt;p&gt;下面定义一个接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Notifier interface {
  Notify() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们定义了一个叫做 &lt;code&gt;Notifier&lt;/code&gt; 的接口并包含一个 &lt;code&gt;Notify&lt;/code&gt; 方法。当一个接口只包含一个方法时，按照 Go 语言的&lt;a href=&#34;http://golang.org/doc/effective_go.html#interface-names&#34;&gt;约定&lt;/a&gt;命名该接口时添加 &lt;code&gt;-er&lt;/code&gt; 后缀。这个约定很有用，特别是接口和方法具有相同名字和意义的时候。&lt;/p&gt;

&lt;p&gt;我们可以在接口中定义尽可能多的方法，不过在 Go 语言标准库中，你很难找到一个接口包含两个以上的方法。&lt;/p&gt;

&lt;h2 id=&#34;实现接口&#34;&gt;实现接口&lt;/h2&gt;

&lt;p&gt;当涉及到我们该怎么让我们的类型实现接口时，Go 语言是特别的一个。Go 语言不需要我们显式的实现类型的接口。如果一个接口里的所有方法都被我们的类型实现了，那么我们就说该类型实现了该接口。&lt;/p&gt;

&lt;p&gt;让我们继续之前的例子，定义一个函数来接受任意一个实现了接口 &lt;code&gt;Notifier&lt;/code&gt; 的类型的值或者指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func SendNotification(notify Notifier) error {
  return notify.Notify()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SendNotification&lt;/code&gt; 函数调用 &lt;code&gt;Notify&lt;/code&gt; 方法，这个方法被传入函数的一个值或者指针实现。这样一来一个函数就可以被用来执行任意一个实现了该接口的值或者指针的指定的行为。&lt;/p&gt;

&lt;p&gt;用我们的 &lt;code&gt;User&lt;/code&gt; 类型来实现该接口并且传入一个 &lt;code&gt;User&lt;/code&gt; 类型的值来调用 &lt;code&gt;SendNotification&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (u *User) Notify() error {
  log.Printf(&amp;quot;User: Sending User Email To %s&amp;lt;%s&amp;gt;\n&amp;quot;,
      u.Name,
      u.Email)
  return nil
}

func main() {
  user := User{
    Name:  &amp;quot;AriesDevil&amp;quot;,
    Email: &amp;quot;ariesdevil@xxoo.com&amp;quot;,
  }
  
  SendNotification(user)
}

// Output:
cannot use user (type User) as type Notifier in function argument:
User does not implement Notifier (Notify method has pointer receiver)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/KG8-Qb7gqM&#34;&gt;http://play.golang.org/p/KG8-Qb7gqM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为什么编译器不考虑我们的值是实现该接口的类型？接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针&lt;a href=&#34;http://golang.org/ref/spec#Method_sets&#34;&gt;实现了&lt;/a&gt;该接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类型 &lt;code&gt;*T&lt;/code&gt; 的可调用方法集包含接受者为 &lt;code&gt;*T&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 的所有方法集&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这条规则说的是如果我们用来调用特定接口方法的接口变量是一个指针类型，那么方法的接受者可以是值类型也可以是指针类型。显然我们的例子不符合该规则，因为我们传入 &lt;code&gt;SendNotification&lt;/code&gt; 函数的接口变量是一个值类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类型 &lt;code&gt;T&lt;/code&gt; 的可调用方法集包含接受者为 &lt;code&gt;T&lt;/code&gt; 的所有方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这条规则说的是如果我们用来调用特定接口方法的接口变量是一个值类型，那么方法的接受者必须也是值类型该方法才可以被调用。显然我们的例子也不符合这条规则，因为我们 &lt;code&gt;Notify&lt;/code&gt; 方法的接受者是一个指针类型。&lt;/p&gt;

&lt;p&gt;语言规范里只有这两条规则，我通过这两条规则得出了符合我们例子的规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类型 &lt;code&gt;T&lt;/code&gt; 的可调用方法集不包含接受者为 &lt;code&gt;*T&lt;/code&gt; 的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们碰巧赶上了我推断出的这条规则，所以编译器会报错。&lt;code&gt;Notify&lt;/code&gt; 方法使用指针类型作为接受者而我们却通过值类型来调用该方法。解决办法也很简单，我们只需要传入 &lt;code&gt;User&lt;/code&gt; 值的地址到 &lt;code&gt;SendNotification&lt;/code&gt; 函数就好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  user := &amp;amp;User{
    Name:  &amp;quot;AriesDevil&amp;quot;,
    Email: &amp;quot;ariesdevil@xxoo.com&amp;quot;,
  }
  
  SendNotification(user)
}

// Output:
User: Sending User Email To AriesDevil&amp;lt;ariesdevil@xxoo.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/kEKzyTfLjA&#34;&gt;http://play.golang.org/p/kEKzyTfLjA&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;嵌入类型&#34;&gt;嵌入类型&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Struct_types&#34;&gt;结构体类型&lt;/a&gt;可以包含匿名或者嵌入字段。也叫做嵌入一个类型。当我们嵌入一个类型到结构体中时，该类型的名字充当了嵌入字段的字段名。&lt;/p&gt;

&lt;p&gt;下面定义一个新的类型然后把我们的 &lt;code&gt;User&lt;/code&gt; 类型嵌入进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Admin struct {
  User
  Level  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们定义了一个新类型 &lt;code&gt;Admin&lt;/code&gt; 然后把 &lt;code&gt;User&lt;/code&gt; 类型嵌入进去，注意这个不叫继承而叫组合。 &lt;code&gt;User&lt;/code&gt; 类型跟 &lt;code&gt;Admin&lt;/code&gt; 类型没有关系。&lt;/p&gt;

&lt;p&gt;我们来改变一下 &lt;code&gt;main&lt;/code&gt; 函数，创建一个 &lt;code&gt;Admin&lt;/code&gt; 类型的变量并把变量的地址传入 &lt;code&gt;SendNotification&lt;/code&gt; 函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  admin := &amp;amp;Admin{
    User: User{
      Name:  &amp;quot;AriesDevil&amp;quot;,
      Email: &amp;quot;ariesdevil@xxoo.com&amp;quot;,
    },
    Level: &amp;quot;master&amp;quot;,
  }
  
  SendNotification(admin)
}

// Output
User: Sending User Email To AriesDevil&amp;lt;ariesdevil@xxoo.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/ivzzzk78TC&#34;&gt;http://play.golang.org/p/ivzzzk78TC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;事实证明，我们可以 &lt;code&gt;Admin&lt;/code&gt; 类型的一个指针来调用 &lt;code&gt;SendNotification&lt;/code&gt; 函数。现在 &lt;code&gt;Admin&lt;/code&gt; 类型也通过来自嵌入的 &lt;code&gt;User&lt;/code&gt; 类型的&lt;strong&gt;&lt;em&gt;方法提升&lt;/em&gt;&lt;/strong&gt;实现了该接口。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;Admin&lt;/code&gt; 类型包含了 &lt;code&gt;User&lt;/code&gt; 类型的字段和方法，那么它们在结构体中的关系是怎么样的呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当我们&lt;a href=&#34;http://golang.org/doc/effective_go.html#embedding&#34;&gt;嵌入&lt;/a&gt;一个类型，这个类型的方法就变成了外部类型的方法，但是当它被调用时，方法的接受者是内部类型(嵌入类型)，而非外部类型。&amp;ndash; Effective Go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此嵌入类型的名字充当着字段名，同时嵌入类型作为内部类型存在，我们可以使用下面的调用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;admin.User.Notify()

// Output
User: Sending User Email To AriesDevil&amp;lt;ariesdevil@xxoo.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/0WL_5Q6mao&#34;&gt;http://play.golang.org/p/0WL_5Q6mao&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这儿我们通过类型名称来访问内部类型的字段和方法。然而，这些字段和方法也同样被提升到了外部类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;admin.Notify()

// Output
User: Sending User Email To AriesDevil&amp;lt;ariesdevil@xxoo.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/2snaaJojRo&#34;&gt;http://play.golang.org/p/2snaaJojRo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;所以通过外部类型来调用 &lt;code&gt;Notify&lt;/code&gt; 方法，本质上是内部类型的方法。&lt;/p&gt;

&lt;p&gt;下面是 Go 语言中内部类型&lt;a href=&#34;http://golang.org/ref/spec#Method_sets&#34;&gt;方法集提升&lt;/a&gt;的规则：&lt;/p&gt;

&lt;p&gt;给定一个结构体类型 &lt;code&gt;S&lt;/code&gt; 和一个命名为 &lt;code&gt;T&lt;/code&gt; 的类型，方法提升像下面规定的这样被包含在结构体方法集中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;S&lt;/code&gt; 包含一个匿名字段 &lt;code&gt;T&lt;/code&gt;，&lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;*S&lt;/code&gt; 的方法集都包含接受者为 &lt;code&gt;T&lt;/code&gt; 的方法提升。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;*S&lt;/code&gt; 类型的方法集包含接受者为 &lt;code&gt;*T&lt;/code&gt; 的方法提升&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这条规则说的是当我们嵌入一个类型，可以被外部类型的指针调用的方法集只有嵌入类型的接受者为指针类型的方法集，也就是说，当外部类型使用指针调用内部类型的方法时，只有接受者为指针类型的内部类型方法集将被提升。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;S&lt;/code&gt; 包含一个匿名字段 &lt;code&gt;*T&lt;/code&gt;，&lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;*S&lt;/code&gt; 的方法集都包含接受者为 &lt;code&gt;T&lt;/code&gt; 或者 &lt;code&gt;*T&lt;/code&gt; 的方法提升&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。&lt;/p&gt;

&lt;p&gt;这就是语言规范里方法提升中仅有的三条规则。&lt;/p&gt;

&lt;h2 id=&#34;回答开头的问题&#34;&gt;回答开头的问题&lt;/h2&gt;

&lt;p&gt;现在我们可以写程序来回答开头提出的两个问题了，首先我们让 &lt;code&gt;Admin&lt;/code&gt; 类型实现 &lt;code&gt;Notifier&lt;/code&gt; 接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (a *Admin) Notify() error {
  log.Printf(&amp;quot;Admin: Sending Admin Email To %s&amp;lt;%s&amp;gt;\n&amp;quot;,
      a.Name,
      a.Email)
      
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Admin&lt;/code&gt; 类型实现的接口显示一条 admin 方面的信息。当我们使用 &lt;code&gt;Admin&lt;/code&gt; 类型的指针去调用函数 &lt;code&gt;SendNotification&lt;/code&gt; 时，这将帮助我们确定到底是哪个接口实现被调用了。&lt;/p&gt;

&lt;p&gt;现在创建一个 &lt;code&gt;Admin&lt;/code&gt; 类型的值并把它的地址传入 &lt;code&gt;SendNotification&lt;/code&gt; 函数，来看看发生了什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  admin := &amp;amp;Admin{
    User: User{
      Name:  &amp;quot;AriesDevil&amp;quot;,
      Email: &amp;quot;ariesdevil@xxoo.com&amp;quot;,
    },
    Level: &amp;quot;master&amp;quot;,
  }
  
  SendNotification(admin)
}

// Output
Admin: Sending Admin Email To AriesDevil&amp;lt;ariesdevil@xxoo.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/JGhFaJnGpS&#34;&gt;http://play.golang.org/p/JGhFaJnGpS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;预料之中，&lt;code&gt;Admin&lt;/code&gt; 类型的接口实现被 &lt;code&gt;SendNotification&lt;/code&gt; 函数调用。现在我们用外部类型来调用 &lt;code&gt;Notify&lt;/code&gt; 方法会发生什么呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;admin.Notify()

// Output
Admin: Sending Admin Email To AriesDevil&amp;lt;ariesdevil@xxoo.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细代码：&lt;a href=&#34;http://play.golang.org/p/EGqK6DwBOi&#34;&gt;http://play.golang.org/p/EGqK6DwBOi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们得到了 &lt;code&gt;Admin&lt;/code&gt; 类型的接口实现的输出。&lt;code&gt;User&lt;/code&gt; 类型的接口实现不被提升到外部类型了。&lt;/p&gt;

&lt;p&gt;现在我们有了足够的依据来回答问题了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译器会因为我们同时有两个接口实现而报错吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不会，因为当我们使用嵌入类型时，类型名充当了字段名。嵌入类型作为结构体的内部类型包含了自己的字段和方法，且具有唯一的名字。所以我们可以有同一接口的内部实现和外部实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果编译器接受这样的定义，那么当接口调用时编译器要怎么确定该使用哪个实现？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果外部类型包含了符合要求的接口实现，它将会被使用。否则，通过方法提升，任何内部类型的接口实现可以直接被外部类型使用。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;在 Go 语言中，方法，接口和嵌入类型一起工作方式是独一无二的。这些特性可以帮助我们像面向对象那样组织结构然后达到同样的目的，并且没有其它复杂的东西。用本文中谈到的语言特色，我们可以以极少的代码来构建抽象和可伸缩性的框架。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言方法接受者类型的选择</title>
      <link>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E8%80%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E8%80%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%89%E6%8B%A9/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;很多人(特别是新手)在写 Go 语言代码时经常会问一个问题，那就是一个方法的接受者类型到底应该是值类型还是指针类型呢，Go 的 wiki 上对这点做了很好的解释，我来翻译一下。
&lt;/p&gt;

&lt;h2 id=&#34;何时使用值类型&#34;&gt;何时使用值类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果接受者是一个 &lt;code&gt;map&lt;/code&gt;，&lt;code&gt;func&lt;/code&gt; 或者 &lt;code&gt;chan&lt;/code&gt;，使用值类型(因为它们本身就是引用类型)。&lt;/li&gt;
&lt;li&gt;如果接受者是一个 &lt;code&gt;slice&lt;/code&gt;，并且方法不执行 &lt;code&gt;reslice&lt;/code&gt; 操作，也不重新分配内存给 &lt;code&gt;slice&lt;/code&gt;，使用值类型。&lt;/li&gt;
&lt;li&gt;如果接受者是一个小的数组或者原生的值类型结构体类型(比如 &lt;code&gt;time.Time&lt;/code&gt; 类型)，而且没有可修改的字段和指针，又或者接受者是一个简单地基本类型像是 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt;，使用值类型就好了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个值类型的接受者可以减少一定数量的垃圾生成，如果一个值被传入一个值类型接受者的方法，一个栈上的拷贝会替代在堆上分配内存(但不是保证一定成功)，所以在没搞明白代码想干什么之前，别因为这个原因而选择值类型接受者。&lt;/p&gt;

&lt;h2 id=&#34;何时使用指针类型&#34;&gt;何时使用指针类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果方法需要修改接受者，接受者必须是指针类型。&lt;/li&gt;
&lt;li&gt;如果接受者是一个包含了 &lt;code&gt;sync.Mutex&lt;/code&gt; 或者类似同步字段的结构体，接受者必须是指针，这样可以避免拷贝。&lt;/li&gt;
&lt;li&gt;如果接受者是一个大的结构体或者数组，那么指针类型接受者更有效率。(多大算大呢？假设把接受者的所有元素作为参数传给方法，如果你觉得参数有点多，那么它就是大)。&lt;/li&gt;
&lt;li&gt;从此方法中并发的调用函数和方法时，接受者可以被修改吗？一个值类型的接受者当方法调用时会创建一份拷贝，所以外部的修改不能作用到这个接受者上。如果修改必须被原始的接受者可见，那么接受者必须是指针类型。&lt;/li&gt;
&lt;li&gt;如果接受者是一个结构体，数组或者 &lt;code&gt;slice&lt;/code&gt;，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接受者，这样会增加程序的可读性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当你看完这个还是有疑虑，还是不知道该使用哪种接受者，那么记住使用指针接受者。&lt;/p&gt;

&lt;h2 id=&#34;关于接受者的命名&#34;&gt;关于接受者的命名&lt;/h2&gt;

&lt;p&gt;社区约定的接受者命名是类型的一个或两个字母的缩写(像 &lt;code&gt;c&lt;/code&gt; 或者 &lt;code&gt;cl&lt;/code&gt; 对于 &lt;code&gt;Client&lt;/code&gt;)。不要使用泛指的名字像是 &lt;code&gt;me&lt;/code&gt;，&lt;code&gt;this&lt;/code&gt; 或者 &lt;code&gt;self&lt;/code&gt;，也不要使用过度描述的名字，最后，如果你在一个地方使用了 &lt;code&gt;c&lt;/code&gt;，那么就不要在别的地方使用 &lt;code&gt;cl&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 new() 和 make() 的区别</title>
      <link>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-new-%E5%92%8C-make-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 25 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-new-%E5%92%8C-make-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;Go 语言中的 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 一直是新手比较容易混淆的东西，咋一看很相似。不过解释两者之间的不同也非常容易。
&lt;/p&gt;

&lt;h2 id=&#34;new-的主要特性&#34;&gt;new 的主要特性&lt;/h2&gt;

&lt;p&gt;首先 &lt;code&gt;new&lt;/code&gt; 是内建函数，你可以从 &lt;a href=&#34;http://golang.org/pkg/builtin/#new&#34;&gt;http://golang.org/pkg/builtin/#new&lt;/a&gt; 这儿看到它，它的定义也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func new(Type) *Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方文档对于它的描述是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;内建函数 &lt;code&gt;new&lt;/code&gt; 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据这段描述，我们可以自己实现一个类似 &lt;code&gt;new&lt;/code&gt; 的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func newInt() *int {
  var i int
  return &amp;amp;i
}

someInt := newInt()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们这个函数的功能跟 &lt;code&gt;someInt := new(int)&lt;/code&gt; 一模一样。所以在我们自己定义 new 开头的函数时，出于约定也应该返回类型的指针。&lt;/p&gt;

&lt;h2 id=&#34;make-的主要特性&#34;&gt;make 的主要特性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 也是内建函数，你可以从 &lt;a href=&#34;http://golang.org/pkg/builtin/#make&#34;&gt;http://golang.org/pkg/builtin/#make&lt;/a&gt; 这儿看到它，它的定义比 &lt;code&gt;new&lt;/code&gt; 多了一个参数，返回值也不同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func make(Type, size IntegerType) Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方文档对于它的描述是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;内建函数 &lt;code&gt;make&lt;/code&gt; 用来为 &lt;code&gt;slice&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt; 或 &lt;code&gt;chan&lt;/code&gt; 类型分配内存和初始化一个对象(&lt;strong&gt;注意&lt;/strong&gt;：只能用在这三种类型上)，跟 &lt;code&gt;new&lt;/code&gt; 类似，第一个参数也是一个类型而不是一个值，跟 &lt;code&gt;new&lt;/code&gt; 不同的是，&lt;code&gt;make&lt;/code&gt; 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Slice: 第二个参数 size 指定了它的长度，它的容量和长度相同。
你可以传入第三个参数来指定不同的容量值，但必须不能比长度值小。
比如 make([]int, 0, 10)

Map: 根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存

Channel: 管道缓冲区依据缓冲区容量被初始化。如果容量为 0 或者忽略容量，管道是没有缓冲区的
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 的作用是初始化一个指向类型的指针(&lt;code&gt;*T&lt;/code&gt;)，&lt;code&gt;make&lt;/code&gt; 的作用是为 &lt;code&gt;slice&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt; 或 &lt;code&gt;chan&lt;/code&gt; 初始化并返回引用(&lt;code&gt;T&lt;/code&gt;)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于 Martini 的跨域资源共享(CORS)</title>
      <link>https://se77en.cc/2014/%E5%9F%BA%E4%BA%8E-martini-%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABcors/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/%E5%9F%BA%E4%BA%8E-martini-%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABcors/</guid>
      <description>&lt;p&gt;##概述&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.w3.org/TR/cors/&#34;&gt;CORS&lt;/a&gt; 的全称是 Cross-Origin Resource Sharing，即：跨域资源共享&lt;/p&gt;

&lt;p&gt;根据我的理解，就是马伊琍和文章结婚了，姚笛就不能和文章结了，如果还想在一起，那就得采用一定的方法，这个方法就是跨域，哦，不对，是当第三者:)

根据维基百科的解释，CORS 是一种机制，这个机制允许一个 Web 页面上 JavaScript 向另外的域发起 XMLHttpRequests 请求，注意不是向该 Web 页面所在域请求。这样的跨域请求，在 CORS 之前，根据同源安全策略是会被浏览器拒绝的。CORS 定义了一种方法，这个方法使浏览器和服务器相互作用来限定是否允许跨域请求。它显然比只有单纯的同源请求有用，而且还比简单的允许所有跨域访问要安全。&lt;/p&gt;

&lt;p&gt;在 CORS 出现之前，已经有了很多种方法来实现跨域访问，其中最有名的就是 JSONP(JSON with Padding)，JSONP 是一种使用 JavaScript 请求其它域服务器的一种通信技术，本质就是利用同源策略的漏洞，一般来说位于 xxoo.se77en.cc 的网页是无法与非 xxoo.se77en.cc 的服务器通信的，但是 HTML 里的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素是一个例外，利用这一例外，可以通过 JavaScript 操作浏览器页面 DOM 来动态创建 Script 对象，再将 Script 的 src 属性指向另一个域的资源，服务器就会将数据伪装成一段 JavaScript 代码来实现跨域目的。不过这种技术只能发起 GET 请求，而且安全隐患极大，因为远程服务器可以发送 JavaScript 代码，所以极易受到跨网站伪造请求(CSRF/XSRF)，所以使用 JSONP 要格外小心。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：目前有个正在进行的计划定义 &lt;a href=&#34;http://json-p.org/&#34;&gt;JSON-P 严格安全子集&lt;/a&gt;，使浏览器可以对 MIME 类别是 &lt;code&gt;application/json-p&lt;/code&gt; 的请求做强制处理，如果不能被解析为严格的 JSON-P，浏览器则会抛出一个错误或者忽略整个响应，目前正确的 JSONP MIME 类型仍然是 &lt;code&gt;application/javascript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对比 JSONP 的限制，CORS 的限制主要是浏览器支持的问题(不过已经很不错了，除了万恶的 IE6)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://se77en.cc/img/cors-with-martini-and-golang/cors-in-broswer.png&#34; alt=&#34;cors-in-broswer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;##创建一个 CORS 请求&lt;/p&gt;

&lt;p&gt;完成一个 CORS 需要前后端配合。&lt;/p&gt;

&lt;p&gt;###前端&lt;/p&gt;

&lt;p&gt;对前端而言，基本没什么变化，还是使用 XMLHttpRequest 对象(IE 使用 XDomainRequest)，增加了参数和响应回调，当然如果你用 jQuery 可以不用考虑这么多了。下面用 JavaScript 和 jQuery 分别示例：&lt;/p&gt;

&lt;p&gt;首先是 JavaScript，比较复杂，所以直接用大牛 Nicholas•Zakas 写的帮助方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();
  if (&amp;quot;withCredentials&amp;quot; in xhr) {

    // 检查 XMLHttpRequest 对象是否包含 &amp;quot;withCredentials&amp;quot; 属性
    // &amp;quot;withCredentials&amp;quot; 只在 XMLHTTPRequest2 对象中存在
    xhr.open(method, url, true);

  } else if (typeof XDomainRequest != &amp;quot;undefined&amp;quot;) {

    // 否则，检查是否是 XDomainRequest
    // XDomainRequest 只在 IE 中存在, 所以用 IE 的方式来创建 CORS 请求
    xhr = new XDomainRequest();
    xhr.open(method, url);

  } else {

    // 上述都不满足，说明浏览器不支持 CORS
    xhr = null;

  }
  return xhr;
}

var xhr = createCORSRequest(&#39;GET&#39;, url);
if (!xhr) {
  throw new Error(&#39;CORS not supported&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想要提交 cookies 需要设置 XMLHttpRequest 的 withCredentials 属性为 true：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xhr.withCredentials = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后处理服务端的返回结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xhr.onload = function() {
 var responseText = xhr.responseText;
 console.log(responseText);
 // 处理返回结果
};

xhr.onerror = function() {
  console.log(&#39;There was an error!&#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;坑爹的是，浏览器在发生错误时的处理方式并不好，FireFox 对于所有错误返回一个为0的状态值和一个空的信息。浏览器会在 console log 里打印一个错误信息，不过这个信息却不能被 JavaScript 访问。所以处理错误时，你只知道一个错误发生了，别的一概不知。&lt;/p&gt;

&lt;p&gt;前端完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建 XHR 对象
function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();
  if (&amp;quot;withCredentials&amp;quot; in xhr) {
    // XHR for Chrome/Firefox/Opera/Safari.
    xhr.open(method, url, true);
  } else if (typeof XDomainRequest != &amp;quot;undefined&amp;quot;) {
    // XDomainRequest for IE.
    xhr = new XDomainRequest();
    xhr.open(method, url);
  } else {
    // 不支持 CORS
    xhr = null;
  }
  return xhr;
}


//创建真正的一个 CORS 请求
function makeCorsRequest() {
  var url = &#39;http://ooxx.se77en.cc&#39;;

  var xhr = createCORSRequest(&#39;GET&#39;, url);
  if (!xhr) {
    alert(&#39;CORS not supported&#39;);
    return;
  }

  // 处理响应
  xhr.onload = function() {
    var text = xhr.responseText;
    alert(&#39;Response from CORS request to &#39; + url);
  };

  xhr.onerror = function() {
    alert(&#39;Woops, there was an error making the request.&#39;);
  };

  xhr.send();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###服务端&lt;/p&gt;

&lt;p&gt;对服务端而言，最简单的处理方法就是增加下面一行到你的 Response Header 里：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 go 来实现就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setAllowOrigin(writer http.ResponseWriter, r *http.Request) {
  writer.Header().Add(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;)
  return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果希望处理 POST，PUT 这类复杂的请求，或者是想要更加精确的控制 CORS，如：允许的域范围，是否允许 Cookie，允许哪些请求方法，那自然处理也会变得复杂一点。&lt;/p&gt;

&lt;p&gt;对于任何非简单请求，浏览器都会先于服务器进行沟通，达成一致后，再发出实际请求。沟通的方式叫做 Preflight(起飞预备)，在发起实际请求前，浏览器首先通过 OPTIONS 方式(这样才能从服务器收到响应)。&lt;/p&gt;

&lt;p&gt;Preflight 请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTIONS /cors HTTP/1.1
Origin: http://ooxx.se77en.cc
Access-Control-Request-Method: POST, PUT
Access-Control-Request-Headers: X-Custom-Header
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 是浏览器要发出的请求类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 是实际请求发送过来时额外的 Header 类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些参数都是可以用逗号分隔的多值字符串。&lt;/p&gt;

&lt;p&gt;Preflight 响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://ooxx.se77en.cc
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 是 CORS 响应的标配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 和 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 是服务器支持的方法和头信息，值得注意的是，这里应该填写全集，而非对应 Preflight 请求里的项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外还有一些可选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 是告诉浏览器多少秒以内，不再需要请求 Preflight&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 是告诉浏览器是否支持 Cookie，对应上面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Preflight 沟通失败：&lt;/p&gt;

&lt;p&gt;如果 Preflight 发送过来的请求权限超过了服务器所支持的，回复的方法是忽略掉 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 即可，就像一个普通的 HTTP 200 返回，这样浏览器就不会发起实际请求了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;沟通成功后的实际请求和响应：&lt;/p&gt;

&lt;p&gt;当浏览器发起 Preflight，并确认服务器支持 CORS 无误，就可以发起实际请求步骤&lt;/p&gt;

&lt;p&gt;实际请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POST /cors HTTP/1.1
Origin: http://ooxx.se77en.cc
Host: xxoo.wisteria.io
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://ooxx.se77en.cc
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;交互过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://se77en.cc/img/cors-with-martini-and-golang/cors_flow.png&#34; alt=&#34;cors_flow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;服务端响应流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://se77en.cc/img/cors-with-martini-and-golang/cors_server_flowchart.png&#34; alt=&#34;cors_server_flowchart&#34; /&gt;&lt;/p&gt;

&lt;p&gt;###如何用 Go 语言实现？&lt;/p&gt;

&lt;p&gt;按照上述过程，首先判断是 Preflight 还是 Actual Request：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (cors *Cors) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  if origin := r.Header.Get(&amp;quot;Origin&amp;quot;); origin == &amp;quot;&amp;quot; {
      cors.corsNotValid(w, r)
      return
  } else if r.Method != &amp;quot;OPTIONS&amp;quot; {
      //actual request.
      cors.actualRequest(w, r)
      return
  } else if acrm := r.Header.Get(&amp;quot;Access-Control-Request-Method&amp;quot;); acrm == &amp;quot;&amp;quot; {
      //actual request.
      cors.actualRequest(w, r)
      return
  } else {
      //preflight request.
      cors.preflightRequest(w, r)
      return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###在 Martini 中实现&lt;/p&gt;

&lt;p&gt;上面代码只是说明意图，下面我们来示范一下 CORS 在 Martini 中的应用。&lt;/p&gt;

&lt;p&gt;首先是页面所在域，假设为 xxoo.wisteria.io&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
  &amp;lt;script src=&amp;quot;http://cdn.staticfile.org/jquery/1.8.2/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    $(function() {
      $(&amp;quot;#btn&amp;quot;).click(function(e){
        e.preventDefault();  //感谢 @A-limon 提醒
        var btx = $(&amp;quot;#btx&amp;quot;).val();
        var url = &amp;quot;http://ooxx.se77en.cc/cors&amp;quot;;
        $.ajax(url, {
          type:&amp;quot;POST&amp;quot;,
          data:{&amp;quot;value&amp;quot;:btx},
          dataType:&amp;quot;json&amp;quot;,
          xhrFields:{
            withCredentials:false
          },
          success:function(data){alert(data.msg);},
          error:function(){alert(&amp;quot;errror&amp;quot;);}
        });
      });
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;CORS&amp;lt;/h1&amp;gt;
  &amp;lt;form&amp;gt;
    &amp;lt;textarea id=&amp;quot;btx&amp;quot; cols=&amp;quot;30&amp;quot; rows=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;submit&amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是服务器所在域，假设为 ooxx.se77en.cc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;github.com/go-martini/martini&amp;quot;
	&amp;quot;github.com/martini-contrib/binding&amp;quot;
	&amp;quot;github.com/martini-contrib/cors&amp;quot;
)

type xxoo struct {
	Value string `form:&amp;quot;value&amp;quot;`
}

func main() {
	m := martini.Classic()
	m.Use(cors.Allow(&amp;amp;cors.Options{
		AllowOrigins:     []string{&amp;quot;http://xxoo.wisteria.io&amp;quot;},
		AllowMethods:     []string{&amp;quot;POST&amp;quot;},
		AllowHeaders:     []string{&amp;quot;Origin&amp;quot;, &amp;quot;x-requested-with&amp;quot;, &amp;quot;Content-Type&amp;quot;, &amp;quot;Content-Range&amp;quot;, &amp;quot;Content-Disposition&amp;quot;, &amp;quot;Content-Description&amp;quot;},
		ExposeHeaders:    []string{&amp;quot;Content-Length&amp;quot;},
		AllowCredentials: false,
	}))

	m.Post(&amp;quot;/cors&amp;quot;, binding.Form(xxoo{}), func(ooxx xxoo, writer http.ResponseWriter) (int, string) {
		writer.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
		log.Println(&amp;quot;******* &amp;quot; + ooxx.Value + &amp;quot; *******&amp;quot;)
		return http.StatusOK, `{&amp;quot;msg&amp;quot;:&amp;quot;hello cors&amp;quot;}`
	})
	
  m.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了 Martini 的一个叫 cors 的插件，可以看到 Martini 的 cors 插件已经为我们做了很多工作，详细说明请参见 &lt;a href=&#34;https://github.com/martini-contrib/cors#usage&#34;&gt;cors 文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;##感谢&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&#34;&gt;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/JSONP&#34;&gt;http://en.wikipedia.org/wiki/JSONP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.html5rocks.com/en/tutorials/cors/&#34;&gt;http://www.html5rocks.com/en/tutorials/cors/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://semicircle.github.io/blog/2013/09/29/go-with-cors/&#34;&gt;http://semicircle.github.io/blog/2013/09/29/go-with-cors/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://client.cors-api.appspot.com/client&#34;&gt;http://client.cors-api.appspot.com/client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://enable-cors.org/&#34;&gt;http://enable-cors.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Go 语言的并发模型--通过通信来共享内存</title>
      <link>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B--%E9%80%9A%E8%BF%87%E9%80%9A%E4%BF%A1%E6%9D%A5%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 08 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://se77en.cc/2014/go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B--%E9%80%9A%E8%BF%87%E9%80%9A%E4%BF%A1%E6%9D%A5%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid>
      <description>&lt;p&gt;##概述&lt;/p&gt;

&lt;p&gt;我一直在找一种好的方法来解释 go 语言的&lt;a href=&#34;http://golang.org/doc/effective_go.html#concurrency&#34;&gt;并发模型&lt;/a&gt;：
&amp;gt; 不要通过共享内存来通信，相反，应该通过通信来共享内存&lt;/p&gt;

&lt;p&gt;但是没有发现一个好的解释来满足我下面的需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过一个例子来说明最初的问题&lt;/li&gt;
&lt;li&gt;提供一个共享内存的解决方案&lt;/li&gt;
&lt;li&gt;提供一个通过通信的解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这篇文章我就从这三个方面来做出解释。&lt;/p&gt;

&lt;p&gt;读过这篇文章后你应该会了解&lt;strong&gt;&lt;em&gt;通过通信来共享内存&lt;/em&gt;&lt;/strong&gt;的模型，以及它和&lt;strong&gt;&lt;em&gt;通过共享内存来通信&lt;/em&gt;&lt;/strong&gt;的区别，你还将看到如何分别通过这两种模型来解决访问和修改共享资源的问题。

##前提&lt;/p&gt;

&lt;p&gt;设想一下我们要访问一个银行账号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Account interface {
  Withdraw(uint)
  Deposit(uint)
  Balance() int
}

type Bank struct {
  account Account
}

func NewBank(account Account) *Bank {
  return &amp;amp;Bank{account: account}
}

func (bank *Bank) Withdraw(amount uint, actor_name string) {
  fmt.Println(&amp;quot;[-]&amp;quot;, amount, actor_name)
  bank.account.Withdraw(amount)
}

func (bank *Bank) Deposit(amount uint, actor_name string) {
  fmt.Println(&amp;quot;[+]&amp;quot;, amount, actor_name)
  bank.account.Deposit(amount)
}

func (bank *Bank) Balance() int {
  return bank.account.Balance()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 &lt;code&gt;Account&lt;/code&gt; 是一个接口，所以我们提供一个简单的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type SimpleAccount struct{
  balance int
}

func NewSimpleAccount(balance int) *SimpleAccount {
  return &amp;amp;SimpleAccount{balance: balance}
}

func (acc *SimpleAccount) Deposit(amount uint) {
  acc.setBalance(acc.balance + int(amount))
}

func (acc *SimpleAccount) Withdraw(amount uint) {
  if acc.balance &amp;gt;= int(amount) {
    acc.setBalance(acc.balance - int(amount))
  } else {
    panic(&amp;quot;杰克穷死&amp;quot;)
  }
}

func (acc *SimpleAccount) Balance() int {
  return acc.balance
}

func (acc *SimpleAccount) setBalance(balance int) {
  acc.add_some_latency()  //增加一个延时函数，方便演示
  acc.balance = balance
}

func (acc *SimpleAccount) add_some_latency() {
  &amp;lt;-time.After(time.Duration(rand.Intn(100)) * time.Millisecond)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能注意到了 &lt;code&gt;balance&lt;/code&gt; 没有被直接修改，而是被放到了  &lt;code&gt;setBalance&lt;/code&gt; 方法里进行修改。这样设计是为了更好的描述问题。稍后我会做出解释。&lt;/p&gt;

&lt;p&gt;把上面所有部分弄好以后我们就可以像下面这样使用它啦：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  balance := 80
  b := NewBank(NewSimpleAccount(balance))
  
  fmt.Println(&amp;quot;初始化余额&amp;quot;, b.Balance())
  
  b.Withdraw(30, &amp;quot;马伊琍&amp;quot;)
  
  fmt.Println(&amp;quot;-----------------&amp;quot;)
  fmt.Println(&amp;quot;剩余余额&amp;quot;, b.Balance())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上面的代码会输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;初始化余额 80
[-] 30 马伊琍
-----------------
剩余余额 50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错！&lt;/p&gt;

&lt;p&gt;不错在现实生活中，一个银行账号可以有很多个附属卡，不同的附属卡都可以对同一个账号进行存取钱，所以我们来修改一下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  balance := 80
  b := NewBank(NewSimpleAccount(balance))
  
  fmt.Println(&amp;quot;初始化余额&amp;quot;, b.Balance())
  
  done := make(chan bool)
  
  go func() { b.Withdraw(30, &amp;quot;马伊琍&amp;quot;); done &amp;lt;- true }()
  go func() { b.Withdraw(10, &amp;quot;姚笛&amp;quot;); done &amp;lt;- true }()
  
  //等待 goroutine 执行完成
  &amp;lt;-done
  &amp;lt;-done
  
  fmt.Println(&amp;quot;-----------------&amp;quot;)
  fmt.Println(&amp;quot;剩余余额&amp;quot;, b.Balance())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这儿两个附属卡并发的从账号里取钱，来看看输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-----------------
剩余余额 70
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这下把文章高兴坏了:)&lt;/p&gt;

&lt;p&gt;结果当然是错误的，剩余余额应该是40而不是70，那么让我们看看到底哪儿出问题了。&lt;/p&gt;

&lt;p&gt;##问题&lt;/p&gt;

&lt;p&gt;当并发访问共享资源时，无效状态有很大可能会发生。&lt;/p&gt;

&lt;p&gt;在我们的例子中，当两个附属卡同一时刻从同一个账号取钱后，我们最后得到银行账号(即共享资源)错误的剩余余额(即无效状态)。&lt;/p&gt;

&lt;p&gt;我们来看一下执行时候的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 处理情况
             --------------
             _马伊琍_|_姚笛_
 1. 获取余额     80  |  80
 2. 取钱       -30  | -10
 3. 当前剩余     50  |  70
                ... | ...
 4. 设置余额     50  ?  70  //该先设置哪个好呢？
 5. 后设置的生效了
             --------------
 6. 剩余余额        70
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面 &lt;code&gt;...&lt;/code&gt; 的地方描述了我们 &lt;code&gt;add_some_latency&lt;/code&gt; 实现的延时状况，现实世界经常发生延迟情况。所以最后的剩余余额就由最后设置余额的那个附属卡决定。&lt;/p&gt;

&lt;p&gt;##解决办法&lt;/p&gt;

&lt;p&gt;我们通过两种方法来解决这个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;共享内存的解决方案&lt;/li&gt;
&lt;li&gt;通过通信的解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的解决方案都是简单的封装了一下 &lt;code&gt;SimpleAccount&lt;/code&gt; 来实现保护机制。&lt;/p&gt;

&lt;p&gt;###共享内存的解决方案&lt;/p&gt;

&lt;p&gt;又叫 “通过共享内存来通信”。&lt;/p&gt;

&lt;p&gt;这种方案暗示了使用锁机制来预防同时访问和修改共享资源。锁告诉其它处理程序这个资源已经被一个处理程序占用了，因此别的处理程序需要排队直到当前处理程序处理完毕。&lt;/p&gt;

&lt;p&gt;让我们来看看 &lt;code&gt;LockingAccount&lt;/code&gt; 是怎么实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type LockingAccount struct {
  lock    sync.Mutex
  account *SimpleAccount
}

//封装一下 SimpleAccount
func NewLockingAccount(balance int) *LockingAccount {
  return &amp;amp;LockingAccount{account: NewSimpleAccount(balance)}
}

func (acc *LockingAccount) Deposit(amount uint) {
  acc.lock.Lock()
  defer acc.lock.Unlock()
  acc.account.Deposit(amount)
}

func (acc *LockingAccount) Withdraw(amount uint) {
  acc.lock.Lock()
  defer acc.lock.Unlock()
  acc.account.Withdraw(amount)
}

func (acc *LockingAccount) Balance() int {
  acc.lock.Lock()
  defer acc.lock.Unlock()
  return acc.account.Balance()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接明了！注意 &lt;code&gt;lock sync.Lock&lt;/code&gt;，&lt;code&gt;lock.Lock()&lt;/code&gt;，&lt;code&gt;lock.Unlock()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这样每次一个附属卡访问银行账号(即共享资源)，这个附属卡会自动获得锁直到最后操作完毕。&lt;/p&gt;

&lt;p&gt;我们的 &lt;code&gt;LockingAccount&lt;/code&gt; 像下面这样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
  balance := 80
  b := NewBank(NewLockingAccount(balance))
  
  fmt.Println(&amp;quot;初始化余额&amp;quot;, b.Balance())
  
  done := make(chan bool)
  
  go func() { b.Withdraw(30, &amp;quot;马伊琍&amp;quot;); done &amp;lt;- true }()
  go func() { b.Withdraw(10, &amp;quot;姚笛&amp;quot;); done &amp;lt;- true }()
  
  //等待 goroutine 执行完成
  &amp;lt;-done
  &amp;lt;-done
  
  fmt.Println(&amp;quot;-----------------&amp;quot;)
  fmt.Println(&amp;quot;剩余余额&amp;quot;, b.Balance())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出的结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-----------------
剩余余额 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在结果正确了！&lt;/p&gt;

&lt;p&gt;在这个例子中第一个处理程序加锁后独享共享资源，其它处理程序只能等待它执行完成。&lt;/p&gt;

&lt;p&gt;我们接着看一下执行时的情况，假设马伊琍先拿到了锁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            处理过程
                        ________________
                        _马伊琍_|__姚笛__
        加锁                   &amp;gt;&amp;lt;
        得到余额            80  |
        取钱               -30  |
        当前余额            50  |
                           ... |
        设置余额            50  |
        解除锁                 &amp;lt;&amp;gt;
                               |
        当前余额                50
                               |
        加锁                   &amp;gt;&amp;lt;
        得到余额                |  50
        取钱                    | -10
        当前余额                |  40
                               |  ...
        设置余额                |  40
        解除锁                  &amp;lt;&amp;gt;
                        ________________
        剩余余额                40

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们的处理程序在访问共享资源时相继的产生了正确的结果。&lt;/p&gt;

&lt;p&gt;###通过通信的解决方案&lt;/p&gt;

&lt;p&gt;又叫 “通过通信来共享内存”。&lt;/p&gt;

&lt;p&gt;现在账号被命名为 &lt;code&gt;ConcurrentAccount&lt;/code&gt;，像下面这样来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ConcurrentAccount struct {
  account     *SimpleAccount
  deposits    chan uint
  withdrawals chan uint
  balances    chan chan int
}

func NewConcurrentAccount(amount int) *ConcurrentAccount{
  acc := &amp;amp;ConcurrentAccount{
    account :    &amp;amp;SimpleAccount{balance: amount},
    deposits:    make(chan uint),
    withdrawals: make(chan uint),
    balances:    make(chan chan int),
  }
  acc.listen()
  
  return acc
}

func (acc *ConcurrentAccount) Balance() int {
  ch := make(chan int)
  acc.balances &amp;lt;- ch
  return &amp;lt;-ch
}

func (acc *ConcurrentAccount) Deposit(amount uint) {
  acc.deposits &amp;lt;- amount
}

func (acc *ConcurrentAccount) Withdraw(amount uint) {
  acc.withdrawals &amp;lt;- amount
}

func (acc *ConcurrentAccount) listen() {
  go func() {
    for {
      select {
      case amnt := &amp;lt;-acc.deposits:
        acc.account.Deposit(amnt)
      case amnt := &amp;lt;-acc.withdrawals:
        acc.account.Withdraw(amnt)
      case ch := &amp;lt;-acc.balances:
        ch &amp;lt;- acc.account.Balance()
      }
    }
  }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ConcurrentAccount&lt;/code&gt; 同样封装了 &lt;code&gt;SimpleAccount&lt;/code&gt; ，然后增加了通信通道&lt;/p&gt;

&lt;p&gt;调用代码和加锁版本的一样，这里就不写了，唯一不一样的就是初始化银行账号的时候：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b := NewBank(NewConcurrentAccount(balance))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行产生的结果和加锁版本一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-----------------
剩余余额 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们来深入了解一下细节。&lt;/p&gt;

&lt;p&gt;###通过通信来共享内存是如何工作的&lt;/p&gt;

&lt;p&gt;一些基本注意点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;共享资源被封装在一个控制流程中。
结果就是资源成为了非共享状态。没有处理程序能够直接访问或者修改资源。你可以看到访问和修改资源的方法实际上并没有执行任何改变。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  func (acc *ConcurrentAccount) Balance() int {
    ch := make(chan int)
    acc.balances &amp;lt;- ch
    balance := &amp;lt;-ch
    return balance
  }
  func (acc *ConcurrentAccount) Deposit(amount uint) {
    acc.deposits &amp;lt;- amount
  }

  func (acc *ConcurrentAccount) Withdraw(amount uint) {
    acc.withdrawals &amp;lt;- amount
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;访问和修改是通过消息和控制流程通信。&lt;/li&gt;
&lt;li&gt;在控制流程中任何访问和修改的动作都是相继发生的。
当控制流程接收到访问或者修改的请求后会立即执行相关动作。让我们仔细看看这个流程：
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  func (acc *ConcurrentAccount) listen() {
    // 执行控制流程
    go func() {
      for {
        select {
        case amnt := &amp;lt;-acc.deposits:
          acc.account.Deposit(amnt)
        case amnt := &amp;lt;-acc.withdrawals:
          acc.account.Withdraw(amnt)
        case ch := &amp;lt;-acc.balances:
          ch &amp;lt;- acc.account.Balance()
        }
      }
    }()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Select_statements&#34;&gt;select&lt;/a&gt; 不断地从各个通道中取出消息，每个通道都跟它们所要执行的操作相一致。&lt;/p&gt;

&lt;p&gt;重要的一点是：在 &lt;code&gt;select&lt;/code&gt; 声明内部的一切都是相继执行的(在同一个处理程序中排队执行)。一次只有一个事件(在通道中接受或者发送)发生，这样就保证了同步访问共享资源。&lt;/p&gt;

&lt;p&gt;领会这个有一点绕。&lt;/p&gt;

&lt;p&gt;让我们用例子来看看 &lt;code&gt;Balance()&lt;/code&gt; 的执行情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         一张附属卡的流程      |   控制流程 
      ----------------------------------------------

 1.     b.Balance()         |
 2.             ch -&amp;gt; [acc.balances]-&amp;gt; ch
 3.             &amp;lt;-ch        |  balance = acc.account.Balance()
 4.     return  balance &amp;lt;-[ch]&amp;lt;- balance
 5                          |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个流程都干了点什么呢？&lt;/p&gt;

&lt;p&gt;###附属卡的流程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用 &lt;code&gt;b.Balance()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新建通道 &lt;code&gt;ch&lt;/code&gt;，将 &lt;code&gt;ch&lt;/code&gt; 通道塞入通道 &lt;code&gt;acc.balances&lt;/code&gt; 中与控制流程通信，这样控制流程也可以通过 &lt;code&gt;ch&lt;/code&gt; 来返回余额&lt;/li&gt;
&lt;li&gt;等待 &lt;code&gt;&amp;lt;-ch&lt;/code&gt; 来取得要接受的余额&lt;/li&gt;
&lt;li&gt;接受余额&lt;/li&gt;
&lt;li&gt;继续&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###控制流程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;空闲或者处理&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;acc.balances&lt;/code&gt; 通道里面的 &lt;code&gt;ch&lt;/code&gt; 通道来接受余额请求&lt;/li&gt;
&lt;li&gt;取得真正的余额值&lt;/li&gt;
&lt;li&gt;将余额值发送到 &lt;code&gt;ch&lt;/code&gt; 通道&lt;/li&gt;
&lt;li&gt;准备处理下一个请求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;控制流程每次只处理一个 &lt;code&gt;事件&lt;/code&gt;。这也就是为什么除了描述出来的这些以外，第2-4步没有别的操作执行。&lt;/p&gt;

&lt;p&gt;##总结&lt;/p&gt;

&lt;p&gt;这篇博客描述了问题以及问题的解决办法，但那时没有深入去探究不同解决办法的优缺点。&lt;/p&gt;

&lt;p&gt;其实这篇文章的例子更适合用 mutex，因为这样代码更加清晰。&lt;/p&gt;

&lt;p&gt;最后，请毫无顾忌的指出我的错误！&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>